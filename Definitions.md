- LTS (Long Term Support) - ...
- MEAN (MongoDb, Express.js, Angular.js, Node.js)
- ELK
----------------
- ECMAScript
- **JavaScript** - мультипарадигменный язык программирования. Поддерживает объектно-ориентированный, императивный и функциональный стили. Является реализацией спецификации ECMAScript (стандарт ECMA-262). Основные архитектурные черты: динамическая типизация, слабая типизация, автоматическое управление памятью, прототипное программирование, функции как объекты первого класса. JavaScript — однопоточный язык программирования. Движок JS единовременно может обрабатывать только одно выражение — в одном потоке.
- **NodeJS** - программная платформа, основанная на движке V8 (транслирующем JavaScript в машинный код), превращающая JavaScript из узкоспециализированного языка в язык общего назначения. Node.js добавляет возможность JavaScript взаимодействовать с устройствами ввода-вывода через свой API, написанный на C++, подключать другие внешние библиотеки, написанные на разных языках, обеспечивая вызовы к ним из JavaScript-кода. Node.js применяется преимущественно на сервере, выполняя роль веб-сервера, но есть возможность разрабатывать на Node.js и десктопные оконные приложения (при помощи NW.js, AppJS или Electron для Linux, Windows и macOS) и даже программировать микроконтроллеры (например, tessel, low.js и espruino). В основе Node.js лежит событийно-ориентированное и асинхронное (или реактивное) программирование с неблокирующим вводом/выводом.
- **Redux** — библиотека для JavaScript с открытым исходным кодом, предназначенная для управления состоянием приложения (Flux, CQRS и Event Sourcing, Redux пытается сделать изменения состояния предсказуемыми, путем введения некоторых ограничений на то, как и когда могут произойти обновления). Вынуждены управлять все большим количеством состояний (State) с помощью JavaScript. Эти состояния могут включать в себя ответы сервера, кэшированные данные, а также данные, созданные локально, но еще не сохраненные на сервере.
Вот несколько советов о том, когда имеет смысл использовать Redux: 1) У вас есть обоснованные объемы данных, меняющихся со временем. 2) Вам нужен один источник информации для вашего состояния. 3) Вы приходите к выводу, что сохранять все ваше состояние в компоненте верхнего уровня уже недостаточно.
- **Saga** - это библиотека, используемая для обработки побочных эффектов в Redux. Когда вы запускаете действие, что-то меняется в состоянии приложения, и вам может потребоваться сделать что-то, вытекающее из этого изменения состояния.
- **Styled Components** - являются одним из новых способов использования CSS в современном JavaScript. Они предназначен для написания CSS, который ограничен одним компонентом. Styled Components — это библиотека для React и React Native для написания и управления CSS. Это решение «CSS-in-JS», то есть вы пишете CSS в файлах Javascript (в частности, в компонентах, которые являются файлами Javascript).
- **Webpack** используется для компиляции JavaScript-модулей. Этот инструмент часто называют «бандлером» (от bundler) или «сборщиком модулей».
- **Babel** — это транспилятор, который, в основном, используется для преобразования конструкций, принятых в свежих версиях стандарта ECMAScript, в вид, понятный как современным, так и не самым новым браузерам и другим средам, в которых может выполняться JavaScript. Babel, кроме того, умеет преобразовывать в JavaScript и JSX-код, используя @babel/preset-react.
- **Babel Preset** - a preset is a set of plugins used to support particular language features.
- **Hooks** нацелены на решение всех этих проблем, позволяя вам писать функциональные компоненты, которые имеют доступ к state, context, методам жизненного цикла, ref и т. д., без написания классов.
- **Mobx** - ...
- **Lighthouse** - ...
----------------
- **Критические этапы рендеринга (Critical Rendering Path)** - это последовательность шагов, которые выполняет браузер, когда преобразуется HTML, CSS и JavaScript в пиксели, которые вы видите на экране. Оптимизация этих шагов улучшает производительность рендера.
Эти этапы включают в себя работу:

- Document Object Model (DOM)
- CSS Object Model (CSSOM)
- Деревом рендера (render tree)
- Компоновкой объектов (layout)
----------------
- WebSocket - ...

```
Task queue — очередь из завершенных асинхронных задач готовых к синхронной обработке. Из этой очереди задачи будут постепенно перемещены в call stack.
Сall stack — стек вызовов по которому можно определить в каком месте программы сейчас идет ее обработка. Если стек не пуст, значит идет выполнение синхронных задач, а именно, функции, которая находится на верхушке стека.
Event loop — механизм перемещающий готовые к синхронной обработке асинхронные задачи из task queue в call stack.
```
- **EventLoop (Цикл событий)** - это однопоточный цикл, который контролирует стек вызовов и проверяет, есть ли какая-либо работа, которую необходимо выполнить в очереди задач. Если стек вызовов пуст и в очереди задач есть callback-функции, то функция удаляется из очереди и помещается с стек вызовов для выполнения. EventLoop выполняет одну простую задачу — осуществляет контроль стека вызовов и очереди обратных вызовов. Если стек вызовов пуст, цикл событий возьмет первое событие из очереди и отправит его в стек вызовов, который его запустит. При вызове нового метода вверху стека выделяется отдельный блок памяти. Стек вызовов отвечает за отслеживание всех операций в очереди, которые должны быть выполнены. При завершении очереди она извлекается из стека. Идея событийного цикла очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых. Общий алгоритм движка: 1) Пока есть задачи: выполнить их, начиная с самой старой 2) Бездействовать до появления новой задачи, а затем перейти к пункту 1. Задача цикла обработки событий ― следить за состоянием стека вызовов и определять пуст он или нет. Если стек пуст, то проверяется message queue, нет ли там вызовов, ожидающих выполнения.
- **Heap (Куча)**. В куче происходит создание нового объекта. 
- **Queue (Очередь)**. Очередь событий отвечает за отправку новых функций на трек обработки. Он следует структуре данных очереди, чтобы поддерживать правильную последовательность, в которой все операции должны отправляться на выполнение. Если проще, то это и есть список задач, которые должны отправиться на обработку и ждут своего часа.
- **Поднятие (hoisting)** - Во время компиляции кода, объявления некоторых переменных и функций поднимаются выше остального кода в пределах своей области видимости. Этот процесс и называется hoisting. Благодаря нему, функция будет успешно вызвана несмотря на то, что в коде ее вызов может идти перед объявлением.
- **Всплытие и погружение** — это фазы жизненного цикла события. Разница заключается в моменте определения факта наступления события. Изначально, при взаимодействии юзера с элементом интерфейса (клик на кнопку, например) событие погружается от объекта window к целевому элементу (target), после наступает стадия всплытия и событие всплывает от target обратно к window. Так, одно и то же событие может быть перехвачено раньше или позже.
- " == и === в JS" - Оба оператора сравнения проверяют тождественность. Различие заключается в том, что двойное равно при сравнении значений неявно приводит (преобразует) типы значений к единому, так строка “1” и цифра 1 при таком сравнении будут равны. Тройное равно не выполняет никаких неявных трансформаций, а значит исходные типы будут иметь значения. Таким образом строка не будет равна числу и не важно что в обоих операндах фигурирует единица.
- **Блочная область видимости** - 
- **Promise** - это объект, представляющий результат успешного или неудачного завершения асинхронной операции. Это новый инструмент для работы с отложенными или асинхронными вычислениями, добавленный в ECMAScript 2015 (6-я версия ECMA-262). До появления «обещаний» асинхронные задачи можно было решать с помощью функций обратного вызова или с помощью обработки событий. Универсальный подход к решению асинхронных задач – обработка событий. Предоставляют удобный способ организации асинхронного кода.
- **Микро-таски** - называется функцией, которая выполняется после того, как функция или программа, которая ее создала, выходит, и только если стек выполнения JavaScript пуст, но перед возвратом управления циклу событий, используемому пользовательским агентом для управления скриптом. среда исполнения. Микрозадача также может ставить в очередь другие микрозадачи.
- **Макро-таски** - представляет собой некоторую дискретную и независимую работу. Это всегда выполнение кода JavaScript, и очередь микро-задач пуста. Очередь макро-задач часто считается такой же, как очередь задач или очередь событий. Однако очередь макро-задач работает так же, как очередь задач. Единственное небольшое различие между ними состоит в том, что очередь задач используется для синхронных операторов, тогда как очередь макро-задач используется для асинхронных операторов.

- **macrotasks:** setTimeout, setInterval, setImmediate, requestAnimationFrame, I/O, UI rendering
- **microtasks:** process.nextTick, Promises, queueMicrotask, MutationObserver

- Обычная функция - ...
- Стрелочная функция - ...
- Virtual DOM - это концепция программирования, в которой идеальное или «виртуальное» представление пользовательского интерфейса хранится в памяти и синхронизируется с «настоящим» DOM при помощи библиотеки, такой как ReactDOM. Этот процесс называется согласованием.
- Теневой DOM (Shadow DOM) — это браузерная технология, предназначенная в основном для определения области видимости переменных и CSS в веб-компонентах.
- React Fiber - новый механизм согласования в React 16, основная цель которого сделать рендеринг виртуального DOM инкрементным.
- Чистая функция - это функция, результат которой зависит только от введенных данных. Она не меняет никакие внешние значения и просто вычисляет результат
- Генератора ES6 - ...
- AJAX - ...
- Reducer - ...
- Замыкание - это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости, в области видимости родительской функции, в области видимости родителя родительской функции и так до глобальной области видимости с помощью цепочки областей видимости. 
- «use strict» — это директива ES5, которая заставляет весь наш код или код отдельной функции выполняться в строгом режиме. Strict (строгий режим)— особый режим работы компилятора, включающий в себя новые возможности и некоторые улучшения обусловленные стандартом ECMAScript 5, при котором изменяется поведение некоторых функций. Включается директивой ‘use strict’. Большинство современных браузеров поддерживают strict режим, однако не все это делают полностью.
- IIFE или Immediately Invoked Function Expression — это функция, которая вызывается или выполняется сразу же после создания или объявления. Для создания IIFE необходимо обернуть функцию в круглые скобки (оператор группировки), превратив ее в выражение, и затем вызвать ее с помощью еще одних круглых скобок. Это выглядит так: (function(){})().
- **Прототипное наследование** - объекты наследуются от других объектов. Простые объекты в JavaScript, созданные с использованием {} фигурных скобок, имеют только один прототип: Object.prototype. Object.prototype, в свою очередь тоже объект, и все свойства и методы Object.prototype доступны для всех объектов.
Массивы, созданные с помощью [] квадратных скобок, имеют несколько прототипов, в том числе Object.prototype и Array.prototype. Это означает, что все свойства и методы Object.prototype и Array.prototype доступны для всех массивов. Одноименные свойства и методы, например .valueOf и .ToString, вызываются из ближайшего прототипа, в этом случае из Array.prototype.
- **Контекст выполнения** - это абстрактная концепция окружения, где код анализируется и выполняется. Всякий раз, когда в JavaScript выполняется код, это происходит внутри контекста выполнения.
-  **Web workers** позволяют вам обработать некоторый JavaScript-код в отдельном потоке, который называется обработчик, таким образом вы можете запускать отдельные блоки JavaScript-кода одновременно. В основном, вы будете использовать воркеры, чтобы запустить ресурсоёмкий процесс, отдельно от основного потока, чтобы не блокировать действия пользователя.
-  **Под потоком**, обычно, понимают одиночный процесс, который может использовать программа, для выполнения своих нужд. Каждый поток может выполнять только одну в текущий момент времени.
-  **this** — ссылка на объект в контексте которого выполняется функция. Другими словами, если внутри функции есть обращение типа this.имя_свойства это значит, что мы обращаемся к свойству объекта в контексте которого эта функция выполняется.
-  **null** — пустое значение,
**undefined** — неопределенное значение
**undeclared** — переменная не была объявлена, вызов ее вызовет ошибку, вызов typeof покажет undefined (для реализации проверки).
- **Замыкание** — прием при котором функция имеет доступ к лексической области видимости своей функции-обертки, которая была выполнена ранее, но не может быть высвобождена из памяти из-за того, что ее собственная область видимости еще используется другой функцией.
- **Native objects** — объекты определенные спецификацией ECMAScript, например, Object (constructor), Date, Math.
**Host objects** — объекты, чья роль заключается в создании исполнительного окружения для ECMAScript, например, window, document, location, history.
- Function Declaration (функция, объявленная в потоке кода) — классическая форма объявление функции.
- Function Expression (функциональное выражение) — альтернативный синтаксис для объявления функции.
- Function.call 
- Function.apply
- Function.prototype.bind
- **const** — переменным объявленным этим оператором должно быть сразу же присвоено значение. В дальнейшем значение не может быть переопределено. Переменная объявленная таким способом не будет видна за пределами блочной области видимости.
- **let** — значение переменной объявленной этим оператором может быть установлено позже, а так же может быть переопределено в будущем. Переменная объявленная таким способом не будет видна за пределами блочной области видимости. Не доступен hoisting. Не поддерживает повторное объявление.
- **var** — значение переменной объявленной этим оператором может быть установлено позже, а так же может быть переопределено в будущем. Переменная объявленная таким способом видна за пределами блочной области видимости. Доступен hoisting. Поддерживает повторное объявление.
- **Функция высшего порядка** — функция которая принимает в качестве аргумента другую функцию или возвращает функцию, т.е работает с другими функциями.
Array.prototype.reduce, Array.prototype.map и Array.prototype.filter — это функции высшего порядка.
- **Каррирование (currying)** — преобразование функций с множеством аргументов в набор вложенных функций с одним аргументом. После вызова такой функции с передачей ей аргумента, она возвращает новую функцию, ожидающую следующего аргумента и так до получения результата.
----------------
- Saga Watcher - ...
- Saga Worker - ...
- Saga Effects - ...
----------------
- CSS Grid (two-dimensional system) - ...
- CSS Flexbox (one-dimensional system) - ...

- BEM (Block Element Modifier) - 

- Absolute Position - ...
- Relative Position - ...
- Fixed Position - ...
- Static Position - ...
- Sticky Position - ...

- Block - ...
- Inline - ...
- Inline-Block - ...

- CSS Counters - ...
- Media queries - ...

*CSS Box Model (Content, Padding, Border, Margin):*
- Content - ...
- Padding - ...
- Border - ...
- Margin - ...

- Resetting CSS - ...
- Normalizing CSS - ...

- **Pseudo-classes** - Псевдо-класс используется для определения особого состояния элемента. Например, его можно использовать для:
Стилизации элемента, когда пользователь наводит на него курсор
Стилизации посещённых и непосещённых ссылок по-разному
Стилизации элемента, когда он находится в фокусе.
- **Pseudo-element** - используется для стилизации определенных частей элемента.Например, его можно использовать для:
Стилизации первой буквы или строки элемента
Вставки содержимого до или после содержимого элемента

- **Descendant Combinator/Cелектор потомков (space)** - соответствует всем элементам, которые являются потомками указанного элемента.
- **Child Combinator/Селектор дочерний (>)** - выбирает все элементы, которые являются потомками указанного элемента.
- **General Sibling Combinator/Общий родственный селектор (~)** - выбирает все элементы, которые являются братьями и сестрами указанного элемента.
- **Adjacent Sibling Combinator/Соседний родственный селектор (+)** - используется для выбора элемента, который находится непосредственно после другого конкретного элемента. Родственные элементы должны иметь один и тот же родительский элемент, а "смежные" элементы должны "следовать после". 

**CSS vendor prefixes:**
```
-webkit-: Android, Chrome, iOS, and Safari
-moz-: Mozilla Firefox
-ms-: Internet Explorer
-o-: Opera
```

- **Responsive design** - разновидность адаптивного дизайна, представляющая собой только «резиновый» макет, т.е. макет, который трансформируется в зависимости от ширины экрана.

- **Адаптивный (Adaptive) веб-дизайн** представляет собой набор дизайнерских методов, опирающихся на опыт применения различных устройств пользователем, а не на сам браузер. Он создается путем наложения определенных размеров, CSS и JavaScript кодов таким образом, чтобы пользователь мог применять имеющееся в наличии оборудование. Адаптивный дизайн, по сути, является синонимом “прогрессивного улучшения (progressive enhancement)”. Адаптивного дизайна, который означает «резиновый» макет, изменяющийся в зависимости от установленного экрана и размера устройств.

- **Оптимистичный UI дизайн** показывает конечное состояние до того как приложение в действительности заканчивает (или даже начинает) операцию.

- Mobile-first strategy
----------------
- Препроцессор CSS - 
- Постпроцессор CSS - 
- LESS
- SASS 
- SCSS
- Stylus
- PostCSS
----------------
- Single Page Application (SPA) - ...

----------------
- IFrame - ...
- 
----------------
- Swashbuckle — это проект с открытым исходным кодом для создания документов Swagger для веб-API, построенных с помощью ASP.NET Core MVC.
- Swagger — это машиночитаемое представление RESTful API, которое обеспечивает поддержку интерактивной документации, создание клиентских пакетов SDK и возможности обнаружения.
----------------
- **The Command and Query Responsibility Segregation (CQRS)** - принцип или парадигма CQRS разделяет назначение запросов (напр. при чтении данных) и команд на обработку данных. Подход проектирования программного обеспечения, при котором код, изменяющий состояние, отделяется от кода, просто читающего это состояние.
- **Event sourcing (источники событий, регистрация событий, генерация событий)** — это мощный архитектурный шаблон, при котором все изменения, вносимые в состояние приложения, сохраняются в той последовательности, в которой они происходили.
- **Сross-cutting concern** — термин из АОП. К сквозной относится «вспомогательная» функциональность модуля, не относящаяся напрямую к выполняемой задаче, но необходимая, например: синхронизация, обработка ошибок, валидация, управление транзациями, кеширование, логирование, мониторинг.
- **Сага** — это механизм, обеспечивающий согласованность данных в микросервисной архитектуре без применения распределенных транзакций.
----------------
- **CAP-теорема** - ...
- **Согласованность данных (consistency)** - ...
- **Доступность (availability)** - ...
- **Устойчивость к разделению (partition tolerance)** - ...
----------------
- **ACID** - ...
- **Atomicity** — Атомарность гарантирует, что каждая транзакция будет выполнена полностью или не будет выполнена совсем. Не допускаются промежуточные состояния.
- **Consistency** — Согласованность: Транзакция, достигающая своего нормального завершения (EOT — end of transaction, завершение транзакции) и, тем самым, фиксирующая свои результаты, сохраняет согласованность базы данных. Другими словами, каждая успешная транзакция по определению фиксирует только допустимые результаты.
- **Isolation** — Изолированность. Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.
- **Durability** — Надёжность: Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя
----------------
- **Потерянная запись** - Когда две транзакции записывают разные значения в одну и ту же ячейку, одно из изменений теряется.
- **Грязное чтение** -  Когда читаются данные, которые в этот момент изменяются транзакцией, а потом транзакция откатывается и данные исчезают.
- **Повторимое чтение** - Когда несколько раз читаются данные, которые в этот момент изменяются транзакцией — каждый раз данные могут отказаться другими.
- **Фантомы** - Одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.
----------------
- MSDTC (Координатора распределенных транзакций Microsoft) - ...
- **Распределенная транзакция** - это транзакция базы данных , в которой две или задействованы несколько сетевых хостов.
----------------
- **CTE (Common table expression/Общие табличные выражения)** - это технология, которая появилась в MS SQL Server 2005 и представляет собой одну из форм повторного использования результатов одного SQL запроса в другом. 
- **Оконные функции** начинаются с оператора OVER и настраиваются с помощью трёх других операторов: PARTITION BY, ORDER BY и ROWS. Про ORDER BY, PARTITION BY и его вспомогательные операторы LAG, LEAD, RANK. Предложение PARTITION BY определяет «окно», т.е. набор строк, характеризуемых равенством значений списка выражений, указанного в этом предложении.
----------------
- **По области действия блокировки бывают:**
**Строчные блокировки** -- действуют только на одну строку таблицы.
**Гранулярные блокировки** -- действуют на всю таблицу или всю страницу и все строки.
**Предикатные блокировки** -- действуют на область, ограниченную предикатами.

- **По строгости блокировки разделяются на:**
Совместные (shared)
Эксклюзивные (exclusive)

- **Эксклюзивной блокировка** - накладывется транзакцией на объект в случае, если выполняемая ей операция изменяет данные. Только одна транзакция может выполнять подобную операцию над объектом, если на него наложена эксклюзивная блокировка. Блокировка не может быть наложена на объект, если на него уже наложена совместная блокировка.
- **Разделямая (совместная) блокировки** - накладывется транзакцией на объект в случае, если выполняемая ей операция S безопасна, то есть не изменяет никаких данных и не имеет побочных эффектов. Все транзакции могут выполнять операцию S над объектом, если на него наложена совместная блокировка.
 ----------------
- Селективность данных - ...
----------------
- **Нормализация** - представляет процесс разделения данных по отдельным связанным таблицам. Нормализация устраняет избыточность данных (data redundancy) и тем самым избежать нарушения целостности данных при их изменении, то есть избежать аномалий изменения (update anomaly). Существуют **7 нормальных форм**. Каждая нормальная форма (за исключением первой) подразумевает, что к данным уже была применена предыдущая нормальная форма. Например, прежде чем применить третью нормальную форму к данным должна быть применена вторая нормальная форма. И строго говоря, база данных считается нормализованной, если к ней применяется третья нормальная форма и выше.

- **Первая нормальная форма (1NF)** предполагает, что сохраняемые данные на пересечении строк и столбцов должны представлять скалярное значение, а таблицы **не должны содержать повторяющихся строк**.
- **Вторая нормальная форма (2NF)** предполагает, что каждый столбец, не являющийся ключом, должен **зависеть от первичного ключа**.
- **Третья нормальная форма (3NF)** предполагает, что каждый столбец, не являющийся ключом, должен **зависеть только от первичного ключа**.
Нормальная форма Бойса-Кодда (BCNF) является немного более строгой версией третьей нормальной формы.
- **Четвертая нормальная форма (4NF)** применяется для устранения многозначных зависимостей (multivalued dependencies) - таких зависимостей, где столбец с первичным ключом имеет связь один-ко-многим со столбцом, который не является ключом. Эта нормальная форма устраняет некорректные отношения многие-ко-многим.
- **Пятая нормальная форма (5NF)** разделяет таблицы на более малые таблицы для устранения избыточности данных. **Разбиение идет до тех пор, пока нельзя будет воссоздать оригинальную таблицу путем объединения малых таблиц**.
- **Шестая нормальная форма (domain key normal form / 6NF)**. Каждое ограничение в связях между таблицами должно зависеть только от ограничений ключа и ограничений домена, где домен представляет набор допустимых значений для столбца. Эта форма предотвращает добавление недопустимых данных путем установки ограничения на уровне отношений между таблицами, но не на уровне таблиц или столбцов. Данная форма, как правило, не применима на уровне СУБД, в том числе и в SQL Server.
----------------
- MapReduce - ...
- Индекса - ...
- Покрывающий индекс (covering index)
- Хранимые процедуры - ...
- Пессиместический и оптимистический подходы к обеспечению согласованности данных
- Типы индексов: Кластеризованный индекс и некластеризованный индекс. 
- Конфигурации индексов: составной индекс, уникальный индекс или покрывающий индекс
- Транзакция — это  набор последовательных операций с базой данных, соединенных в одну логическую единицу.
----------------
- Связи между таблицами бывают следующих типов:
Один к одному (One to one)
Один к многим (One to many)
Многие ко многим (Many to many)
----------------
- **Ссылочная целостность данных (referential integrity)**:
**Аномалия удаления (deletion anomaly)**. Возникает при удалении строки из главной таблицы. В этом случае внешний ключ из зависимой таблицы продолжает ссылаться на удаленную строку из главной таблицы
**Аномалия вставки (insertion anomaly)**. Возникает при вставке строки в зависимую таблицу. В этом случае внешний ключ из зависимой таблицы не соответствует первичному ключу ни одной из строк из главной таблицы.
**Аномалии обновления (update anomaly)**. При подобной аномалии несколько строк одной таблицы могут содержать данные, которые принадлежат одному и тому же объекту. При изменении данных в одной строке они могу прийти в противоречие с данными из другой строки.

----------------
- Процесс - ...
- Поток - ...
- Нить - ...
- Куча - ...
- Стек памяти - ...
----------------
- x86 - ...
- x64 - ...
----------------
- **Оптимистичная блокировка** - происходит как можно позже, чтобы транзакции реже ждали друг-друга. Плата за такой вид блокировки — необходимость обрабатывать “конфликт обновления”. Конфликт обновления происходит, например, когда “ваша” транзакция прочитала строки и хочет их обновить, но другая транзакция их уже обновила — при оптимистичной блокировке эта ошибка возникнет в “вашей” транзакции и её надо корректно обработать: как минимум, повторить транзакцию позже, как максимум, обработать ошибку прямо в коде транзакции.
- **Пессимистичная блокировка** - происходит как можно раньше, чтобы предотвратить как можно больше побочных эффектов, но транзакции чаще ждут друг-друга. Например, блокирование на обновление строк, которые прочитала транзакция в режиме read committed — это пессимистичная блокировка, потому что она происходит, как только ваша транзакция прочитала строки, не смотря на то, будет ли их кто-то обновлять или нет.
----------------
- **Уровень изоляции** - задает степень защищенности выбираемых транзакцией данных от возможности изменения другими транзакциями:

- **READ UNCOMMITTED** - Чтение неподтверждённых данных (read uncommitted)
Самый низкий уровень изоляции. Можно свободно читать незафиксированные изменения других транзакций, но запись идет строго последовательно. Таким образом, исключается только проблема потерянных обновлений: гарантируется, что в итоге в ячейку запишут нужное значение все транзакции по очереди. Обычно для этого используют блокировку на запись ячеек, предназначенных для изменения в рамках текущей транзакции. На чтение блокировки не ставятся.
- **READ COMMITTED** - Чтение подтверждённых данных (read committed). Можно свободно читать все изменения своей транзакции и зафиксированные изменения чужих транзакций. Исключаются потерянные обновления и грязное чтение, остаются проблемы неповторяемых чтений и фантомов.
- **REPEATABLE READ** - Повторяемое чтение (repeatable read). Можно читать все изменения только своей транзации. Данные, измененные другими транзакциями, недоступны. Остается только проблема фантомных чтений.
- **SERIALIZABLE** - Сериализуемый (serializable). Транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует.
- **SNAPSHOT** - обеспечивается созданием нашей отдельной версии данных, с которыми мы работаем, без блокировок*. Другие транзакции не будут иметь доступ к нашей версии, чем и обеспечивается отсутствие всего вплоть до фантомных чтений. Это оптимистичный вид блокировки, но менее оптимистичный, чем read committed snapshot, так как больше шансов получить конфликт обновления.

- Уровни изоляции READ UNCOMMITTED, REPEATABLE READ и SERIALIZABLE доступны только в пессимистической модели одновременного конкурентного доступа, тогда как уровень SNAPSHOT доступен только в оптимистической модели одновременного конкурентного доступа.
----------------
**Виды JOIN:**
- **INNER JOIN** - Из строк левой_таблицы и правой_таблицы объединяются и возвращаются только те строки, по которым выполняются условия_соединения.
- **LEFT OUTER JOIN** - Возвращаются все строки левой_таблицы (ключевое слово LEFT). Данными правой_таблицы дополняются только те строки левой_таблицы, для которых выполняются условия_соединения. Для недостающих данных вместо строк правой_таблицы вставляются NULL-значения.
- **RIGHT OUTER JOIN** - Возвращаются все строки правой_таблицы (ключевое слово RIGHT). Данными левой_таблицы дополняются только те строки правой_таблицы, для которых выполняются условия_соединения. Для недостающих данных вместо строк левой_таблицы вставляются NULL-значения.
- **FULL OUTER JOIN** - Возвращаются все строки левой_таблицы и правой_таблицы. Если для строк левой_таблицы и правой_таблицы выполняются условия_соединения, то они объединяются в одну строку. Для строк, для которых не выполняются условия_соединения, NULL-значения вставляются на место левой_таблицы, либо на место правой_таблицы, в зависимости от того данных какой таблицы в строке не имеется.
- **CROSS JOIN** - Объединение каждой строки левой_таблицы со всеми строками правой_таблицы. Этот вид соединения иногда называют декартовым произведением.

- FULL OUTER JOIN похоже на CROSS JOIN, но имеет важные отличия. Первое отличие состоит в том, что для FULL OUTER JOIN требуется условие объединения.
----------------
*Операторы (итераторы) плана выполнения в SQL Server:*

- Select (Result)
- Clustered Index Scan 
- NonClustered Index Scan 
- Clustered Index Seek
- NonClustered Index Seek
- Hash Match
- Nested Loops
- Merge Join
- Sort
- Key Lookup
- Compute Scala
- Constant Scan
- Table Scan
- RID Lookup
----------------
- ORM - ...
- EntityFramework - ...
- EntityFramework Core - ...
- Database First - ...
- Code First - ...
- Model First - ...
- **Eager Loading (Жадная загрузка - Include)** - суть Eager Loading заключается в том, чтобы использовать для подгрузки связанных по внешнему ключу данных метод **Include**.
- **Explicit loading (Явная загрузка - Load)** - Явная загрузка предусмативает применение метода **Load()** для загрузки данных в контекст.
- **Lazy Loading (Ленивая загрузка - Virtual)** - При таком способе подгрузки при первом обращении к объекту, если связанные данные не нужны, то они не подгружаются. Однако при первом же обращении к навигационному свойству эти данные автоматически подгружаются из бд. При использовании ленивой загрузки надо иметь в виду некоторые моменты при объявлении классов. Так, классы, использующие ленивую загрузку должны быть публичными, а их свойства должны иметь модификаторы public и virtual.
- **EDMX** - концептуальной, логической и физической модели данных. EDMX is Visual Studio's "container" for all things about your Entity Data Model. It contains all the information that is in the CSDL, SSDL, MSL, plus information about the visual layout of the tables in your Visual Studio designer surface. Edmx file contains EF metadata artifacts (CSDL/MSL/SSDL content)
- CSDL - ...
- SSDL - ...
- MSL - ...
----------------
- Бинарное дерево - ...
- B-tree - ...
- B-tree+ - такое же, как дерево B; единственное отличие состоит в том, что в дереве B + есть дополнительный уровень, добавленный внизу со связанными листьями. Кроме того, в отличие от дерева B, каждый узел дерева B + содержит только ключи, а не пары ключ-значение.
- Heap - ...

- **Бинарное дерево** используется, когда записи хранятся в оперативной памяти (маленький и быстрый), а **B-дерево** используется, когда записи хранятся на диске (большой и медленный). Таким образом, использование B-дерева вместо Binary tree значительно сокращает время доступа из-за высокого коэффициента ветвления и уменьшенной высоты дерева.
----------------
- Шардирование - ...
----------------
- NoSQL - ...
----------------
- **Селективность** - число строк удовлетворяющих предикату/всего строк в таблице.
- **Кардинальность** - это и есть предположительное число строк, которое вернёт запрос
----------------
**5 видов тестовых двойников:**

**Stub:**
- **Dummy (Пустышка)** - это простое, жестко закодированное значение, такое как null значение или выдуманная строка. Он используется для удовлетворения сигнатуры метода SUT и не участвует в получении конечного результата.
- **Стаб (Stub)** - это полноценная зависимость, которую вы настраиваете для возврата разных значений для разных сценариев.
- **Фейк** - это то же самое, что и стаб для большинства целей. Разница заключается в причинах его создания: фейк обычно используется для замены еще не существующей зависимости.

**Mock:**
- **Мок (mock)**
- **Spies (шпионы)** - выполняют ту же роль, что и моки. Отличие в том, что spies пишутся вручную, а моки создаются с помощью готовых инструментов. Иногда spies называют рукописными моками.
----
- **Моки (Mock/Spy)** -  помогают имитировать и изучать исходящие (outcoming) взаимодействия. То есть вызовы, совершаемые тестируемой системой (SUT) к ее зависимостям для изменения их состояния.
- **Стабы (Stub/Dummy/Fake)** - помогают имитировать входящие (incoming) взаимодействия. То есть вызовы, совершаемые SUT к ее зависимостям для получения входных данных.\

- Mocks используют для того, чтобы проверить, была ли функция вызвана с правильными аргументами, а stubs, чтобы протестировать, как функция работает с полученным ответом.
- Стабы нужны для проверки состояния метода, а моки используются для регулировки поведения.
- Стабы предназначены для получения нужного состояния тестируемого объекта, а моки применяются для проверки ожидаемого поведения тестируемого объекта.
- Стабы никогда не применяются в утверждениях, они простые «слуги», которые лишь моделируют внешнее окружение тестового класса; при этом в утверждениях проверяется состояние именно тестового класса, которое зависит от установленного состояния стаба.

- Use Fakes when you want a re-usable concrete implementation that works similar to the real implementation with re-usability across tests (e.g. In Memory Database)
- Use Stubs when you want a hardcoded response/implementation that will be re-used across tests
- Use Mocks when you need dynamic responses for individual tests, that may not necessarily require re-usability across tests
----------------
- E2E-тестирование - ...
- Интеграционное тестирование - ...
- Юнит-тестирование - ...
----------------
**This is a list of Automated Testing Frameworks for .NET related to methodologies and types of tests:**

- Test-Driven Development (TDD) - ...
- Behavior-Driven Development (BDD) - ...
- Specification by Example (SBE) - ...
- Acceptance Test-Driven Development (ATDD) - ...
- Property-Based Testing (PBT) - ...
- Unit / Integration / Acceptance / Specification / etc. Tests - ...
----------------
- NodeJS vs Javascript: https://www.educba.com/javascript-vs-node-js/
----------------
- **CLR ("Common Language Runtime", "общеязыковая исполняющая среда")**  - это компонент .NET Framework, основной задачей которого является управление интерпретацией и исполнением кода IL. CLR отвечает за изоляцию памяти приложений, проверку типов, безопасность кода, преобразование IL в машинный код.

- **IL (Intermediate Language)**  - код, содержащий набор инструкций, не зависящих от платформы. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.

- **CLS ("Common Language Specification", общеязыковая спецификация)** - это набор правил, следуя которым разработчики достигают бесконфликтной работы во всех языках .NET.

- **CTS, Система общих типов (Common Type System)** - ...

- **BCL, библиотека базовых классов** - ..

- **Framework class library (FCL)** - ...

- **.NET Framework** - ...

- **.NET Core** - ...

- **.NET Standard** - ...
----------------
- **Куча больших объектов (Large Object Heap, LOH)** - это специальная область, зарезервированная для размещения очень больших объектов. Большими считаются объекты, занимающие больше 85 Кбайт памяти. Это - пороговое значение относится к одному объекту, а не к графу объектов с корнем в данном объекте, поэтому массив из 1000 строк (по 100 символов в каждой) не считается большим объектом, так как сам массив содержит лишь 4- или 8-байтные ссылки на строки, а вот массив из 50 000 целых чисел - это большой объект.
----------------
- **Асинхронность** подразумевает выполнение операции в стиле, не подразумевающем блокирование вызвавшего потока, то есть запуск операции без ожидания ее завершения.
- **Многопоточность** — параллельное выполнение, **асинхронность** — логическая оптимизация выполнения, которая может работать и в одном, и во многих потоках.
- **Параллелизм** - эта программная модель подразумевает, что задача разбивается на несколько независимых подзадач, которые можно выполнить параллельно, а затем объединить результаты
- **Процесс (Process)** — объект ОС, изолированное адресное пространство, содержит потоки.
- **Поток (Thread)** — объект ОС, наименьшая единица выполнения, часть процесса, потоки делят память и другие ресурсы между собой в рамках процесса.
- **Многозадачность** — свойство ОС, возможность выполнять несколько процессов одновременно
- **Многоядерность** — свойство процессора, возможность использовать несколько ядер для обработки данных
- **Многопроцессорность** — свойство компьютера, возможность одновременно работать с несколькими процессорами физически
- **Многопоточность** — свойство процесса, возможность распределять обработку данных между несколькими потоками.
- **Параллельность** — выполнение нескольких действий физически одновременно в единицу времени
- **Асинхронность** — выполнение операции без ожидания окончания завершения этой обработки, результат же выполнения может быть обработан позднее.
----------------
- **Замыкание (closure)** представляет объект функции, который запоминает свое лексическое окружение даже в том случае, когда она выполняется вне своей области видимости.

Технически замыкание включает три компонента:
- внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные и параметры - лексическое окружение
- переменные и параметры (лексическое окружение), которые определены во внешней функции
- вложенная функция, которая использует переменные и параметры внешней функции
----------------
- **Ковариантность (``IBank <out T>``)** - позволяет использовать более конкретный тип, чем заданный изначально: 
- **Контравариантность (``ITransaction<in T>``)** - позволяет использовать более универсальный тип, чем заданный изначально: 
- **Инвариантность** - позволяет использовать только заданный тип
----------------
**Базовые принципы ООП:** 

- **Абстракция**  — отделение концепции от ее экземпляра;
- **Полиморфизм**  — реализация задач одной и той же идеи разными способами;
- **Наследование**  — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;
- **Инкапсуляция**  — размещение одного объекта или класса внутри другого для разграничения доступа к ним.
----------------
- Делегация — перепоручение задачи от внешнего объекта внутреннему;
- Композиция — включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого;
- Агрегация — включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование.
----------------
**SOLID (Single Responsibility, Open–Closed, Liskov Substitution, Interface Segregation, Dependency Inversion)**- это 5 принципов объектно-ориентированного программирования, описывающих архитектуру программного обеспечения

- **Принцип единственной обязанности (Single Responsibility):** Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.

- **Принцип открытости/закрытости (Open–Closed):** Программные сущности должны быть открыты для расширения, но закрыты для изменений.

- **Принцип подстановки Барбары Лисков (Liskov Substitution):** Методы, использующие некий тип, должны иметь возможность использовать его подтипы, не зная об этом.

- **Принцип разделения интерфейсов (Interface Segregation):** Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются.

- **Принцип инверсии зависимостей (Dependency Inversion):** Система должна конструироваться на основе абстракций «сверху вниз»: не абстракции должны формироваться на основе деталей, а детали должны формироваться на основе абстракций.
----------------
- State space explosion - ...
----------------
- array of structures (AoS)
- structure of arrays (SoA) 
- array of structures of arrays (AoSoA)
----------------
- Утинная типизация - ...
- Monkey patching - ...
----------------
- **Lock-free** – lock-free считается та процедура, для которой гарантируется прогресс как минимум одного потока, выполняющего эту процедуру. Другие потоки могут ждать, но один поток минимум должен прогрессировать. Разделяемый объект называется lock-free объектом (неблокируемым, non-blocking объектом), если он гарантирует, что некоторый поток закончит выполнение операции над объектом за конечное число шагов вне зависимости от результата работы других потоков (даже если эти другие потоки завершились крахом).
- **Wait-free** – операция называется wait-free в том случае, если она завершается за определенное количество шагов, не зависящих от состояние и действий других потоков.

- Использовании некоторых конструкций, применяющихся для осуществления неблокирующей синхронизации. Речь пойдёт о ключевом слове volatile, функциях VolatileRead, VolatileWrite и MemoryBarrier. System.Threading.Barrier — это определяемый пользователем примитив синхронизации, позволяющий нескольким потокам (которые называются участниками) параллельно осуществлять поэтапную работу с алгоритмом. Каждый участник выполняется до достижения точки барьера в коде. Барьер означает окончание одного этапа работы. Когда участник достигает барьера, он блокируется до тех пор, пока все участники не достигнут этого барьера.
----------------
- **Domain-driven design (Предметно-ориентированное проектирование, реже проблемно-ориентированное)** — это набор принципов и схем, направленных на создание оптимальных систем объектов. Сводится к созданию программных абстракций, которые называются моделями предметных областей. В эти модели входит бизнес-логика, устанавливающая связь между реальными условиями области применения продукта и кодом. Основной целью применения DDD является получение высококачественной модели программного обеспечения, которая будет максимально точно отражать поставленные бизнес-цели.

**Основные концепции:**
- Ubiquitous Language (Единый язык)
- Bounded Context (Ограниченный контекст) - это явная граница, внутри которой существует модель предметной области, которая отображает единый язык в модель программного обеспечения.
- Предметная область (Domain)
- Смысловое ядро (Core domain)
- Пространство задач и пространство решений
- Entity
- Value Object
- Domain Service
- Domain Event
- Module(Модуль)
- Factory
- Aggregate - называется кластер из объектов сущностей или значений. У каждого агрегата есть корень Aggregate Root и граница, внутри которой всегда должны быть удовлетворены инварианты. Все обращения к агрегату должны осуществляться через его корень, который представляет собой сущность с глобально уникальным идентификатором. Все внутренние объекты агрегата имеют только локальную идентичность, они могут ссылаться друг на друга как угодно. Внешние объекты могут хранить только ссылку на корень, а не на внутренние объекты.
- Repository(Репозиторий) - область памяти, которая предназначена для безопасного хранения помещенных в нее элементов. Именно этим является Репозиторий в DDD. Репозиторий используется для агрегатов. Помещая агрегат в соответствующий Репозиторий , а затем извлекая его оттуда, вы получаете целостный объект. Если агрегат будет изменен, то изменения будут сохранены. Если агрегат будет удален, то его уже нельзя будет извлечь.
----------------
- Pattern Repository - ...
- Pattern UnitOfWork - ...
- Паттерн "Спецификация" - ...
- DAL - ...
- BAL - ...
- DTO - ...
- POCO - ...
- Value Object- ...

```
LinqSpecs
```
----------------
- Clean Architecture - ...
- MVC - ...
- MVVM - ...
- SOA - ...
----------------
- SpecFlow (BDD) - ...
- State Machine - ...
- Stateless Library (C#) - ...
- Middleware - ...
- Blazer - ...
----------------
- WebSocket - ...
- WebTranspor - ...
- SignalR - ...
- Sticky Sessions - ...
- HTTP 1/1 - 
- HTTP/2 -  - 
- Handshake - ...
----------------
Для обмена сообщениями между клиентом и сервером SignalR использует ряд механизмов:
1) WebSockets
2) Server-Side Events
3) Long Polling
----------------
- WCF - ...
- IIS - ...
- **Kestrel** — это кроссплатформенный веб-сервер для ASP.NET Core. Kestrel — это веб-сервер, который по умолчанию включается в шаблоны проектов ASP.NET Core.

**Kestrel поддерживается в следующих сценариях:**

- HTTPS
- Непрозрачное обновление для поддержки WebSocket
- Сокеты UNIX для повышения производительности при работе за Nginx
- HTTP/2 (за исключением macOS†)
----------------
- OData - ...
- GraphQL - ...
----------------
- Nginx - ...
- Apach - ...
----------------
- JSONP - ...
- CORS - ...
- Message Pack - ...
----------------
- **SOAP** - протокол обмена xml-сообщениями.
- **REST** (**Representational State Transfer** — «передача репрезентативного состояния» или «передача „самоописываемого“ состояния») — архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Другими словами, REST — это набор правил о том, как программисту организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать.[1] REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. Representational State Transfer — это архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Архитектурный стиль – это набор согласованных ограничений и принципов проектирования, позволяющий добиться определённых свойств системы.
- **6 принципов REST:**

1)Клиент-серверная архитектура
2) Stateless
3) Кэширование
4) Единообразие интерфейса
5) Layered system
6) Code on demand

- **Spec-first development** это философия о том, как разрабатывать API более эффективно. Если вы следуете философии «сначала спецификация», вы сначала пишете спецификацию и используете ее в качестве контракта, к которому разработчики пишут код.
----------------
- **Identity Server** - это сервер проверки подлинности, который реализует стандарты openid connect Подключение (OIDC) и OAuth 2,0 для ASP.NET Core. Он предназначен для предоставления общего способа проверки подлинности запросов ко всем приложениям независимо от того, являются ли они веб-приложениями, собственными, мобильными или интерфейсными конечными точками API. IdentityServer можно использовать для реализации единого Sign-On (единого входа) для нескольких приложений и типов приложений. Его можно использовать для проверки подлинности реальных пользователей с помощью форм входа и аналогичных пользовательских интерфейсов, а также для проверки подлинности на основе служб, которая обычно включает выдачу, проверку и обновление маркеров без какого-либо пользовательского интерфейса. 
- **SSO (Single Sign-On)** — технология, при использовании которой пользователь переходит из одного раздела портала в другой, либо из одной системы в другую, не связанную с первой системой, без повторной аутентификации.
- OAuth2 - ...
- OpenID Connect (OIDC) - ...
- JWT (Json Web Token) - ...
- SWT (Simple Web Token) - ...
- SAML - ...
- Single sign-on (SSO) - ...
- Аутентификация - ...
- Авторизация - ...
- Token-based аутентификация - ...
- Implicit flow (SSO) - ...
- Authorization Code Flow (SSO) - ...
----------------
- RFC - ...
----------------
- SRE (Site reliability engineering) - это набор принципов и практик, который включает аспекты разработки программного обеспечения и применяет их к проблемам инфраструктуры и эксплуатации. Основные цели - создание масштабируемых и высоконадежных программных систем. Разработка надежности сайта тесно связана с DevOps , набором практик, сочетающих разработку программного обеспечения и ИТ-операции, а SRE также описывается как конкретная реализация DevOps.
----------------
- Prometheus - ...
- Grafana - ...
----------------
- DevOps — это технологическая структура, которая обеспечивает взаимодействие между командами разработчиков и операционными командами для более быстрого развертывания кода в производственных средах с возможностью повторения действий и автоматизации.
----------------
- Docker - ...
- Docker-File - ...
- Docker-Compose - ...
- Entrypoint.sh - ...
- 
----------------
- *Kubernetes* - является проектом с открытым исходным кодом, предназначенным для управления кластером контейнеров Linux как единой системой. Kubernetes управляет и запускает контейнеры Docker на большом количестве хостов, а так же обеспечивает совместное размещение и репликацию большого количества контейнеров.

*Концепции Kubernetes:*

- Nodes (node.md): Нода это машина в кластере Kubernetes.
- Pods (pods.md): Pod это группа контейнеров с общими разделами, запускаемых как единое целое.
- Replication Controllers (replication-controller.md): replication controller гарантирует, что определенное количество «реплик» pod'ы будут запущены в любой момент времени.
- Services (services.md): Сервис в Kubernetes это абстракция которая определяет логический объединённый набор pod и политику доступа к ним.
- Volumes (volumes.md): Volume(раздел) это директория, возможно, с данными в ней, которая доступна в контейнере.
- Labels (labels.md): Label'ы это пары ключ/значение которые прикрепляются к объектам, например pod'ам. Label'ы могут быть использованы для создания и выбора наборов объектов.
- Kubectl Command Line Interface (kubectl.md): kubectl интерфейс командной строки для управления Kubernetes.

*Сервисы Kubernetes:*
- ClusterIP - ...
- NodePort - ...
- Ingres - ...

----------------
- GITLAB CI/CD - ...
- JENKINS - ...
- **CI (Continuous Integration)** — практика разработки программного обеспечения, которая заключается в постоянном слиянии рабочих копий в общую основную ветвь разработки (до нескольких раз в день) и выполнении частых автоматизированных сборок проекта для скорейшего выявления потенциальных дефектов и решения интеграционных проблем
- **CD (Continuous delivery или CD, или CDE)** — это подход к разработке программного обеспечения, при котором программное обеспечение производится короткими итерациями, гарантируя, что ПО является стабильным и может быть передано в эксплуатацию в любое время, а передача его не происходит вручную[1]. Целью является сборка, тестирование и релиз программного обеспечения с большей скоростью и частотой. Подход позволяет уменьшить стоимость, время и риски внесения изменений путём более частных мелких обновлений в продакшн-приложение. Непрерывная доставка отличается от непрерывного развертывания (Continuous deployment) тем, что процесс развертывания в производственную среду должен быть подтвержден вручную.
- **Continuous deployment** - ...
- **Гипервизор** — это процесс, который отделяет операционную систему компьютера и приложения от базового физического оборудования. Обычно представляет собой программное обеспечение, хотя создаются и встроенные гипервизоры, например, для мобильных устройств. Гипервизор — технология развертывания программного обеспечения на физическом оборудовании с использованием виртуализации. Инструмент ускоряет и упрощает разработку, тестирование и поддержку программного обеспечения, а также экономит ресурсы на развертывании дорогостоящих серверных систем. Selectel предлагает современные технологии виртуализации серверов (VPS/VDS), а также рабочих мест (VDI). Гипервизор, он же монитор виртуальных машин, — это программное обеспечение для создания и запуска виртуальных машин. С его помощью можно запустить на одном компьютере несколько гостевых операционных систем. Это достигается с помощью разделения ресурсов, например, оперативной памяти, процессорного времени и т.п., сокращая требования к памяти, дисковому пространству и обслуживанию. Есть два типа гипервизоров:
----------------
- **gRPC** - это система удалённого вызова процедур (RPC) с открытым исходным кодом, первоначально разработанная в Google в 2015 году. В качестве транспорта используется HTTP/2, в качестве языка описания интерфейса — Protocol Buffers. gRPC предоставляет такие функции как аутентификация, двунаправленная потоковая передача и управление потоком, блокирующие или неблокирующие привязки, а также отмена и тайм-ауты. Генерирует кроссплатформенные привязки клиента и сервера для многих языков. Чаще всего используется для подключения служб в микросервисном стиле архитектуры и подключения мобильных устройств и браузерных клиентов к серверным службам
- **Protobuf** — это эффективный способ сериализации структурированных данных для компьютеров, предназначенных для чтения и записи, без издержек, которые могут возникнет в удобочитаемых форматах, таких как XML или JSON.
----------------
- Kafka - ...
- **Memcached** - программное обеспечение, реализующее сервис кэширования данных в оперативной памяти на основе хеш-таблицы
- RabbitMQ - ...
- **Брокер сообщений** (англ. message broker, integration broker, interface engine) — архитектурный паттерн в распределённых системах; приложение, которое преобразует сообщение по одному протоколу от приложения-источника в сообщение протокола приложения-приёмника, тем самым выступая между ними посредником.  Брокер сообщений — это технология, обеспечивающая связь между приложениями и помогающая создать общий механизм интеграции для поддержки облачных, микросервисных, бессерверных и гибридных архитектур.

- Брокеры сообщений работают по двум основным **шаблонам (стилям) обмена сообщениями**:
1) **Двухточечный обмен сообщениями**
2) **Модель издатель/подписчик**

**Терминология Брокеров сообщений:**
- **Producer** - тот, кто отправляет сообщения брокеру называют продюсером.
- **Consumer** - Тому, кому RabbitMQ отправляет сообщения называют консумером (Consumer).
- **Exchange** - Сообщения отправляются в обменник (Exchange). Он распределяет сообщения по нескольким очередям.

- **Consumer** - ...
- Reactive Extensions - ...
- Pull Model - ...
- Push Model - ...
- **AMPQ (Advanced Message Queueing Protocol)** - это открытый протокол для асинхронного обмена сообщениями. Каждый байт переданной информации будет гарантированно доставлен. Эта характеристика позволяет писать библиотеки на любых языках и запускать на разных операционных системах и архитектурах CPU, что делает его действительно совместимым и кроссплатформенным стандартом.
- At-least-once delivery (“как минимум однократная доставка”) - ...
- Exactly-once delivery (“строго однократная доставка”) - ...
----------------
**RabbitMQ:**
- Queue - ...
- Exchanges - ...
----------------
- **Elasticsearch (ES)** – масштабируемая утилита полнотекстового поиска и аналитики, которая позволяет быстро в режиме реального времени хранить, искать и анализировать большие объемы данных. ES является ядром ELK-стека (Elastic Stack), в состав которого, помимо Elasticsearch, входят следующие продукты.

Из ключевых функциональных возможностей Elasticsearch стоит отметить следующие :

- **автоматическая индексация новых JSON-объектов**, которые загружаются в базу и сразу становятся доступными для поиска, за счет отсутствия схемы согласно типичной NoSQL-концепции. Это позволяет ускорить прототипирование поисковых Big Data решений.
- **поддержка восточных языков** (китайский, японский, корейский);
- **гибкость поисковых фильтров**, включая нечеткий поиск и мультиарендность, когда в рамках одного объекта ES можно динамически организовать несколько различных поисковых систем;
- **наличие встроенных анализаторов текста** позволяет Elasticsearch автоматически выполнять токенизацию, лемматизацию, стемминг и прочие преобразования для решения NLP-задач, связанных с поиском данных.

**ELK-стека (Elastic Stack):**
- **Logstash** – инструмент сбора, преобразования и сохранения в общем хранилище событий из различных источников (файлы, базы данных, логи и пр.) в реальном времени;
- **Kibana** – веб-интерфейс для Elasticsearch, чтобы взаимодействовать с данными, которые хранятся в его индексах ES через динамические панели мониторинга, таблицы, графики и диаграммы, которые отображают изменения в ES-запросах в реальном времени;
- **FileBeat** – агент на серверах для отправки различных типов оперативных данных в ES.
----------------
- **Redis (REmote DIctionary Server)** — это не реляционная структура данных в памяти, используемая в качестве базы данных. Данные хранятся в виде пары ключ-значение. И при этом хранилище умеет масштабироваться путем репликации между серверами. Redis сохраняет все данные в памяти, что позволяет сделать доступ к данным максимально быстрым по сравнению с другими базами данных. Периодически Redis сбрасывает все данные на диск, но если сервер упадет в момент между добавлением новой информации и сохранением на диск, данные будут потеряны. 

**Redis обычно применяют:**

- для хранения пользовательских сессий (HTML-фрагменты веб-страниц или товары корзины интернет-магазина);
- для хранения промежуточных данных (поток сообщений на стене, голосовалки, таблицы результатов);
- как брокер сообщений (стратегия «издатель-подписчик» позволяет создавать новостные ленты, групповые чаты);
- как СУБД для небольших приложений, блогов;
- для кэширования данных из основного хранилища, что значительно снижает нагрузку на реляционную базу данных;
- для хранения «быстрых» данных — когда важны скорость и критичны задержки передачи (аналитика и анализ данных, финансовые и торговые сервисы)
----------------
- DNS (англ. Domain Name System «система доменных имён») — компьютерная распределённая система для получения информации о доменах. Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства), получения информации о маршрутизации почты и/или обслуживающих узлах для протоколов в домене (SRV-запись).
- Handshake - is an automated process of negotiation between two participants (example "Alice and Bob") through the exchange of information that establishes the protocols of a communication link at the start of the communication, before full communication begins. The handshaking process usually takes place in order to establish rules for communication when a computer attempts to communicate with another device. Signals are usually exchanged between two devices to establish a communication link. For example, when a computer communicates with another device such as a modem, the two devices will signal each other that they are switched on and ready to work, as well as to agree to which protocols are being used.
- CDN (Content Delivery Network) — это географически распределённая сетевая инфраструктура, обеспечивающая быструю доставку контента пользователям веб-сервисов и сайтов. Входящие в состав CDN cерверы географически располагаются таким образом, чтобы сделать время ответа для пользователей сайта/сервиса минимальным. Ориджин (origin) — сервер, на котором хранятся исходные файлы или данные, раздаваемые через CDN
- DHCP (англ. Dynamic Host Configuration Protocol — протокол динамической настройки узла) — прикладной протокол, позволяющий сетевым устройствам автоматически получать IP-адрес и другие параметры, необходимые для работы в сети TCP/IP. Данный протокол работает по модели «клиент-сервер». Для автоматической конфигурации компьютер-клиент на этапе конфигурации сетевого устройства обращается к так называемому серверу DHCP и получает от него нужные параметры. Сетевой администратор может задать диапазон адресов, распределяемых сервером среди компьютеров. Это позволяет избежать ручной настройки компьютеров сети и уменьшает количество ошибок. Протокол DHCP используется в большинстве сетей TCP/IP.
- FTP - ...
- SMTP - ...
----------------
- SSL - ...
- TLS - ...
- CORS (Cross Origin Resource Sharing) - ...
- **XSRF/CSRF Подделка межсайтовых запросов (также известная как XSRF или CSRF)** — это атака на веб-приложения, с помощью которой вредоносное веб-приложение может повлиять на взаимодействие между браузером клиента и веб-приложением, которое доверяет этому браузеру. Эти атаки возможны, поскольку веб-браузеры автоматически отправляют некоторые типы токенов проверки подлинности при каждом запросе на веб-сайт. Такая форма атаки также называется атакой одним щелчком или обкрытием сеанса , поскольку атака использует преимущества ранее проверенного сеанса пользователя.
----------------
- Web scraping - ...
----------------
- **АСД (Абстрактное синтаксическое дерево)** - ...
----------------
- **Coroutines** are computer program components that generalize subroutines for non-preemptive multitasking, by allowing execution to be suspended and resumed.
