- **DDL (Data Definition Language)** - `CREATE`, `ALTER`, `DROP`
- **DML (Data Manipulation Language)** - `SELECT`, `INSERT`, `UPDATE`, `DELETE`
- **TCL (Transaction Control Language)** - `COMMIT`, `ROLLBACK`, `SAVEPOINT`
- **DCL (Data Control Language)** - `GRANT`, `REVOKE`, `DENY`
--------------------------------------------
- `nchar` and `nvarchar` can store Unicode characters.
- `char` and `varchar` cannot store Unicode characters.
- `char` and `nchar` are fixed-length which will reserve storage space for number of characters you specify even if you don't use up all that space.
- `varchar` and `nvarchar` are variable-length which will only use up spaces for the characters you store. It will not reserve storage like char or nchar.
--------------------------------------------
- Составной vs Покрывающий индекс
- Индекс представления (VIEW)
- Плюсы создания ластеризованного индекса не по первичному ключу
- Индекс vs ограничение на уникальность значения
- Можно ли создать кластеризованный индекс на столбце, содержащем дубликаты?
- Почему таблица не может иметь два кластеризованных индекса?
--------------------------------------------
- **PRIMARY KEY** constraint creates a **clustered index by default**.
- **UNIQUE** constraint creates a **non-clustered index by default**.
--------------------------------------------
- **Кучей** является таблица без кластеризованного индекса. Для таблиц, сохраненных как куча, может быть создан один или несколько некластеризованных индексов. Данные хранятся в куче без указания порядка.
- Все индексы имеют одинаковую структуру (structure). Они состоят из:

1) наборов страниц;
2) узлов, имеющих древовидную структуру, иерархическую по природе.

- **Фильтруемым (Filtered) индексом** называют оптимизированный Nonclustered index, в котором задействован предикат фильтра для индексации части строк в таблице.
- **Составным** называют индекс, который:

1) может включать более одного (до 16) столбцов, выступающих ключевыми значениями;
2) ограничивается общей длиной (не превышающей 900 байт);
3) содержит поля, которые принадлежат единой таблице.

- **Уникальным (Unique)** называют индекс, обеспечивающий уникальное значение всех строк по определенному ключу и гарантирующий, что в ключе индекса не будет значений одинаковых, повторяющихся. Для составного ключа понятие уникальности касается всех index columns, но не распространяется на каждый столбец в отдельности.
- **Колоночным (Columnstore)** называют индекс, в котором данные хранятся в столбцах.
- **Пространственным (Spatial)** называют тип расширенного индекса, позволяющего индексировать столбцы с пространственными данными (представленные в типах Geography или Geometry).
- **Полнотекстовые (Full-text)** индексы применяются для повышения эффективности поиска определенных слов в строках, где данные представлены в символах.
- **Покрывающим (Covering)** называют индекс, позволяющий на конкретный запрос получать запрашиваемую информацию в полном объеме с листьев индекса, не обращаясь к записям таблицы. А значит, в Covering index хранится достаточный объем данных для полноценного ответа на запрос. Потому нет необходимости обращаться к таблице.
- **XML-индекс** – специфический тип индекса, предназначенный для работы с данными в столбцах таблицы, представленными в соответствующем формате. Он делает более эффективной обработку поисковых запросов к ним.
--------------------------------------------
**The overview of Database Paradigms:**
- https://tudip.com/blog-post/7-database-paradigms/
- https://www.jigsawacademy.com/blogs/cloud-computing/database-sharding

```
/* Clustered index */
ALTER TABLE MyTable
    ADD CONSTRAINT PK_MyTable
        PRIMARY KEY(WidgetId);
 
/* Clustered index */  
ALTER TABLE MyTable
    ADD CONSTRAINT PK_MyTable
        PRIMARY KEY CLUSTERED(WidgetId);
 
/* Non-clustered index */  
ALTER TABLE MyTable
    ADD CONSTRAINT PK_MyTable
        PRIMARY KEY NONCLUSTERED(WidgetId);
 
 
/* Non-clustered index */  
ALTER TABLE MyTable
    ADD CONSTRAINT UC_MyTable_WidgetNumber
        UNIQUE(WidgetNumber);
 
/* Non-clustered index */  
ALTER TABLE MyTable
    ADD CONSTRAINT UC_MyTable_WidgetNumber
        UNIQUE NONCLUSTERED(WidgetNumber);
 
/* Clustered index */  
ALTER TABLE MyTable
    ADD CONSTRAINT UC_MyTable_WidgetNumber
        UNIQUE CLUSTERED(WidgetNumber);
```
--------------------------------------------
- mssql exection plan
--------------------------------------------
*Типы констрейнтов:*

- Check constraint
- Default constraint
- Foreign key
- Primary key
- Unique clustered index
- Unique constraint
- Unique index

- https://dataedo.com/kb/query/sql-server/list-all-table-constraints
--------------------------------------------
```
select * from INFORMATION_SCHEMA.COLUMNS 
where COLUMN_NAME like '%COLUMN_NAME%' 
order by TABLE_NAME
```
--------------------------------------------
```
SELECT *
FROM INFORMATION_SCHEMA.TABLES 
WHERE INFORMATION_SCHEMA.TABLES.TABLE_NAME like '%TABLE_NAME%'

SELECT COUNT(*)
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_TYPE = 'BASE TABLE'
```
--------------------------------------------
```
SELECT sys.schemas.name AS T2,
t.NAME AS TableName,
p.rows AS RowCounts
FROM 
sys.tables t
INNER JOIN 
sys.partitions p ON t.object_id = p.OBJECT_ID 
JOIN sys.schemas ON t.schema_id = sys.schemas.schema_id
WHERE 
t.NAME LIKE '%TABLE_NAME%' 
AND t.is_ms_shipped = 0
AND p.rows <> 0
GROUP BY t.Name, sys.schemas.name, p.Rows
ORDER BY t.Name
```
--------------------------------------------
```
SELECT  K.TABLE_NAME,
K.COLUMN_NAME ,
K.CONSTRAINT_NAME
FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C
JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K ON C.TABLE_NAME = K.TABLE_NAME
AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG
AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA
AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME
WHERE C.CONSTRAINT_TYPE = 'PRIMARY KEY'
AND K.COLUMN_NAME = 'COLUMN_NAME';
```
--------------------------------------------
```
DECLARE @xmltmp xml = (SELECT * FROM table FOR XML AUTO)
PRINT CONVERT(NVARCHAR(MAX), @xmltmp)
```
--------------------------------------------
```
CREATE TABLE A (
ID INT IDENTITY(1,1) PRIMARY KEY,
... Other Columns
)

CREATE TABLE B
(
ID UNIQUEIDENTIFIER DEFAULT NEWID() PRIMARY KEY,
... Other Columns
)

CREATE TABLE C
(
ID UNIQUEIDENTIFIER DEFAULT NEWSEQUENTIALID() PRIMARY KEY,
... Other Columns
)
```
--------------------------------------------
- How to Create Login, User & Assign Permissions in SQL Server: https://www.guru99.com/sql-server-create-user.html
--------------------------------------------
- Индексы создаются для столбцов таблиц и представлений. Индексы предоставляют путь для быстрого поиска данных на основе значений в этих столбцах. Например, если вы создадите индекс по первичному ключу, а затем будете искать строку с данными, используя значения первичного ключа, то SQL Server сначала найдет значение индекса, а затем использует индекс для быстрого нахождения всей строки с данными. Без индекса будет выполнен полный просмотр (сканирование) всех строк таблицы, что может оказать значительное влияние на производительность.
- Вы можете создать индекс на большинстве столбцов таблицы или представления. Исключением, преимущественно, являются столбцы с типами данных для хранения больших объектов (LOB), таких как image, text или varchar(max). Вы также можете создать индексы на столбцах, предназначенных для хранения данных в формате XML, но эти индексы устроены немного иначе, чем стандартные и их рассмотрение выходит за рамки данной статьи.
- Индекс состоит из набора страниц, узлов индекса, которые организованы в виде древовидной структуры — сбалансированного дерева. 
- Кластеризованный индекс хранит реальные строки данных в листьях индекса. Возвращаясь к предыдущему примеру, это означает что строка данных, связанная со значение ключа, равного 123 будет храниться в самом индексе. Важной характеристикой кластеризованного индекса является то, что все значения отсортированы в определенном порядке либо возрастания, либо убывания. Таким образом, таблица или представление может иметь только один кластеризованный индекс.
- Таблица не имеющая кластеризованного индекса называется кучей.
- В отличие от кластеризованного индекса, листья некластеризованного индекса содержат только те столбцы (ключевые), по которым определен данный индекс, а также содержит указатель на строки с реальными данными в таблице. Это означает, что системе подзапросов необходима дополнительная операция для обнаружения и получения требуемых данных.
- Некластеризованные индексы не могут быть отсортированы в отличие от кластеризованных, однако вы можете создать более одного некластеризованного индекса на таблице или представлении, вплоть до 999.
- В дополнение к возможности создать несколько некластеризованных индексов, вы можете также включить дополнительные столбцы (included column) в свой индекс: на листьях индекса будет храниться не только значение самих индексированных столбцов, но и значения этих не индексированных дополнительных столбцов.
- В дополнение к тому, что индекс может быть либо кластеризованным, либо некластеризованным, возможно его дополнительно сконфигурировать как составной индекс, уникальный индекс или покрывающий индекс.
- Составной индекс - индекс может содержать более одного столбца. Вы можете включить до 16 столбцов в индекс, но их общая длина ограничена 900 байтами.
- Уникальный индекс - такой индекс обеспечивает уникальность каждого значения в индексируемом столбце.
- Покрывающий индекс- такой индекс позволяет конкретному запросу сразу получить все необходимые данные с листьев индекса без дополнительных обращений к записям самой таблицы.
- Насколько полезны индексы могут быть, настолько аккуратно они должны быть спроектированы. Поскольку индексы могут занимать значительное дисковое пространство, вы не захотите создавать индексов больше, чем необходимо. В дополнение, индексы автоматически обновляются когда сама строка с данными обновляется, что может привести к дополнительным накладным расходам ресурсов и падению производительности.
- Наилучшим образом будет применение кластеризованного индекса на столбцах с уникальными значениями и не позволяющими использовать NULL.
- Уникальность значений в столбце влияет на производительность индекса. В общем случае, чем больше у вас дубликатов в столбце, тем хуже работает индекс. С другой стороны, чем больше уникальных значения, тем выше работоспособность индекса. Когда возможно используйте уникальный индекс.
- Для составного индекса возьмите во внимание порядок столбцов в индексе. Столбцы, которые используются в выражениях WHERE (к примеру, WHERE FirstName = 'Charlie') должны быть в индексе первыми. Последующие столбцы должны быть перечислены с учетом уникальности их значений (столбцы с самым высоким количеством уникальных значений идут первыми).
- Кластеризованный индекс – это и есть таблица. Когда вы создаете кластеризованный индекс у таблицы, подсистема хранения данных сортирует все строки в таблице в порядке возрастания или убывания, согласно определению индекса. Кластеризованный индекс это не отдельная сущность как другие индексы, а механизм сортировки данных в таблице и облегчения быстрого доступа к строкам с данными.
- Но в некоторых случаях вы возможно захотите оставить таблицы в их естественном первозданном состоянии, т.е. в виде кучи, и создать лишь некластеризованные индексы для поддержания работоспособности ваших запросов. К примеру, таблица, хранящая лог, преимущественно используется для вставки значений до тех пор пока не будет архивирована. В куче вы не увидите разбиением страниц и фрагментацию данных, как это случается с кластеризованным индексом, потому что строки просто добавляются в конец кучи. Слишком большое разделение страниц может иметь значительное влияние на производительность и в не самом хорошем смысле. В общем, куча позволяет производить вставку данных относительно безболезненно и вам не надо будет бороться с накладными расходами на хранение и обслуживание, как это бывает в случае кластеризованного индекса.
- **Коэффициент заполнения индекса** определяет количество пространства на странице для хранения индекса на нижнем уровне (уровень листьев) перед тем как начать заполнять новую страницу.
- Можно ли создать кластеризованный индекс на столбце, содержащем дубликаты? И да, и нет. Да вы можете создать кластеризованный индекс на ключевом столбце, содержащем дубликаты значений. Нет, значение ключевого столбца не смогут остаться в состоянии не уникальности. Позвольте объяснить. Если вы создаёте неуникальный кластерный индекс (non-unique clustered index) на столбце, то подсистема хранения данных добавляет к дублирующему значению целочисленное значение (uniquifier), чтобы удостовериться в уникальности и, соответственно, обеспечить возможность идентифицировать каждую строку в кластеризованной таблице. Но значение ключевого столбца обязательно должны быть уникальны, поэтому подсистема хранения данных изменит значение дубликатов таким образом, что они будут выглядеть примерно так: Adams, Franklin, Hancock, Hancock1234, Washington, Smith, Smith4567 и Smith5678.
- SQL Server поддерживает два типа таблиц: кластеризованные таблицы, имеющие кластеризованный индекс и таблицы-кучи или просто кучи.
- Какая взаимосвязь между ограничениями на уникальность значения и первичным ключом с индексами таблицы? Первичный ключ и и ограничение уникальности обеспечивают, что значения в столбце будут уникальны. Вы можете создать только один первичный ключ у таблицы и он не может содержать значения NULL. Вы можете создать у таблицы несколько ограничений на уникальность значения и каждый из них может иметь единственную запись с NULL.
- Обязательно ли создавать кластеризованный индекс на столбце с первичным ключом? Вы можете создать кластеризованный индекс на любой столбце, соответствующем необходимым условиям. Это верно, что кластеризованный индекс и ограничение первичного ключа созданы друг для друга и их брак заключен на небесах, так что усвойте факт, что когда вы создаете первичный ключ, тогда же будет автоматически создан кластеризованный индекс, если он не был создан ранее. Тем не менее, вы можете решить, что кластеризованный индекс будет лучше работать в другом месте, и часто ваше решение будет вполне оправданным.
- Когда вы создаете кластеризованный или некластеризованный индекс у предастваления, то данные физически сохраняются на диск, аналогично обычному индексу. В дополнение, когда в нижележащих таблицах изменяются данные, то индекс представления автоматически изменяется (это означает, что вы можете захотеть избежать индексирования представлений тех таблиц, в которых происходят частые изменения). В любом случае, представление остается представлением — взглядом на таблицы, но именно выполненном в данный момент, с индексами ему соответствующими. Перед тем как вы сможете создать индекс у представления, оно должно соответствовать нескольким ограничениям. К примеру, представление может ссылаться только на базовые таблицы, но не другие представления и эти таблицы должны находиться в той же самой базе данных.
- Коэффициент уникальности значений ключевого столбца называется избирательностью индекса.
- Внешний ключ необязательно должен соответствовать первичному ключу из главной таблицы. Хотя, как правило, внешний ключ из зависимой таблицы указывает на первичный ключ из главной таблицы.
