- **RxJS** — это библиотека, используемая для создания асинхронных программ с использованием наблюдаемых последовательностей.
- Реактивная парадигма была сделана для обработки этих «событий» с обновлениями в режиме реального времени по всей программе. Реактивные программы структурированы вокруг событий, а не последовательного выполнения итеративного кода сверху вниз. Это позволяет им реагировать на триггерное событие независимо от того, на каком этапе находится программа.
- Одна из основных концепций реактивного программирования — синхронные и асинхронные данные. Короче говоря, синхронные данные доставляются по одному в кратчайшие сроки.
Асинхронные данные ожидают установленного события, а затем доставляются сразу через «обратный вызов». Асинхронные данные более популярны в реактивном программировании, потому что они хорошо соответствуют подходу парадигмы, основанному на событиях.
- Асинхронные данные более популярны в реактивном программировании, потому что они хорошо соответствуют подходу парадигмы, основанному на событиях.

**Преимущества:**
- Основное преимущество реактивного программирования заключается в том, что оно позволяет программе **реагировать на события независимо от текущей задачи программы**.
- **Высокая масштабируемость**
- **Чистый и читаемый**
- Легко добавить **поддержку нового события или ответа**
- Улучшенный пользовательский интерфейс благодаря **небольшому времени простоя**

--------------------------------------------------------
- Реактивная парадигма доступна для многих языков через реактивные расширения или Rx-библиотеки. Эти библиотеки представляют собой загружаемые API-интерфейсы, которые добавляют **поддержку основных реактивных инструментов, таких как наблюдатели и реактивные операторы**. 
- RxJS — это, в частности, инструмент функционального реактивного программирования **с шаблоном наблюдателя и шаблоном итератора**. Он также включает **адаптированную форму функций массива JavaScript (сокращение, отображение и т. Д.)** Для обработки асинхронных событий как коллекций.
--------------------------------------------------------
```
of(1,2,3).pipe(
  map(value => value * 2)
).subscribe({
  next: console.log
});
```

```
of(1, 2, 3).pipe(
  // пропускаем только нечетные значения
  filter(value => value % 2 !== 0),
  map(value = value * 2)
).subscribe({
  next: console.log
});
```

```
const observable = new Observable((observer) => {
  observer.next(1);
  observer.next(2);
  observer.complete();
});
```
